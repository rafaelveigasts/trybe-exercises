## Concluindo

Hoje conceituamos algoritmo como uma série de passos para resolver um problema e vimos que existem algoritmos corretos e não corretos.

Aprendemos que podemos dizer qual a Ordem de Complexidade de algoritmos, e que essa é uma forma de analisá-los quanto à taxa de crescimento de tempo de execução, ou de consumo de memória, para seus valores de entrada e saída; sendo que essa análise pode ser feita para quaisquer linguagem e paradigma.

As complexidades que estudamos foram:
Constantes: O(1);
Logarítmicos: O(log n);
Linear: O(n);
Quadráticos: O(n²);
Cúbicos: O(n³);
Exponencial: O(2ⁿ);
Fatorial: O(n!).

Vimos também que, a depender do algoritmo, essas análises podem ser combinadas, como por exemplo num algoritmo O(n log n). Além disso, aprendemos que problemas que não têm solução conhecida em tempo polinomial, e que podem ser resolvidos apenas com força bruta, com complexidades exponencial ou fatorial, são chamados NP Completo.

Comparamos algoritmos com várias estruturas de repetição diferentes e percebemos que devemos sempre considerar a maior Ordem de Complexidade possível para representá-los e desprezar as demais na nossa notação.

E, por fim, vimos que algoritmos podem ter diferentes ordens de complexidade para seu melhor caso, pior caso e caso médio.
